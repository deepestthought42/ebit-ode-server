* todos 
* logbook
** initial ode
- the plan: write the ode in julia
- to avoid complications with handing over the arrays in the beginning, start by
  generating the matrix in lisp (as will be the case anyways), write it out, read it in in
  julia and then use it
** setting up lisp package to create matrices
#+BEGIN_SRC lisp :results none
(ql:quickload :with-project-dir)
(ql:quickload :fare-quasiquote)
#+END_SRC

#+BEGIN_SRC lisp :results none
(with-project-dir:with-project-dir ("/home/renee/phd/src/ebit-evolution.project/")
  (ql:quickload :ebit-interaction-rates)
  (ql:quickload :mgl-gnuplot))
#+END_SRC
*** so, what to do ?
- create a list of indices
- for every index, iterate over the all indices and collect the rate infos
- then, add them appropriately
*** [2018-08-09 Thu 10:05] created rates
- NA: create and integrate protobuf protocol
- then, try it:
#+BEGIN_SRC lisp :results none
(in-package :ebit-interaction-rates)


(write-decay-rates-to-file (make-instance 'ebit-system
					  :nuclides
					  (list (nubase:get-entry-for 20 8)))
			   "/home/renee/tmp/test.serialized"
			   :if-exists :overwrite)


(get-decay-rates (make-instance 'ebit-system
				:nuclides
				(list (nubase:get-entry-for 20 8))))

(proto:deserialize-object-from-file 'ebitode:rate-list "/home/renee/tmp/test.serialized")
#+END_SRC

- renamed protobuf msgs for interaction rates
- now need to use this [[ebit-interaction-rates protobuf code]]
- that seems to work, let's try reading some protobuf files in julia
- ok, I can solve the ODE, but the solution is wrong, so the rates are probably wrong
- ODE seems to be ok, plotting in julia is a disaster, start tomorrow by writing protobuf files
*** [2018-08-11 Sat 10:38] test calling julia from lisp
- okay, we get segfaults upon garbage collection after initializing julia
#+BEGIN_SRC lisp
(ql:quickload :with-project-dir)
(defvar cl-user::*cffi-julia-configuration* '(:julia-location "/home/renee/src/julia-d386e40c17/"))
#+END_SRC

#+RESULTS:
: *CFFI-JULIA-CONFIGURATION*

#+BEGIN_SRC lisp
(with-project-dir:with-project-dir ("/home/renee/phd/src/charge-distribution.project/")
  (ql:quickload :cffi-julia))
#+END_SRC

#+RESULTS:
| :CFFI-JULIA |

#+BEGIN_SRC lisp
(in-package #:cffi-julia)
(jl-init)
#+END_SRC

#+RESULTS:
: ; No value
** [2018-08-13 Mon 09:36] so, let's introduce a pipeserver in julia 
and connect to it 
*** but first: test protobuf protocol via a file
#+BEGIN_SRC lisp
(with-project-dir:with-project-dir ("/home/renee/phd/src/ebit-evolution.project/")
  (ql:quickload :ebit-ode-interface))
#+END_SRC

#+RESULTS:
| :EBIT-ODE-INTERFACE |

#+BEGIN_SRC lisp 
(in-package #:ebit-ode-interface)

(defun generate-decade-reporting (start-decade points-per-decade end)
  (iter outer
    (for decade from (log start-decade 10) below (log end 10) by 1d0)
    (for dec = (expt 10 decade))
    (for dec+1 = (expt 10 (1+ decade)))
    (iter
      (for val from dec below dec+1
	   by (/ (- dec+1 dec) (1- points-per-decade)))
      (unless (> val end)
	(in outer (collect val))))))


(defun make-diff-eq-params (system)
  (let+ (((&slots eir:initial-populations eir:initial-temperature-in-ev
		  eir:trap-length-in-m eir::nuclide-indices eir:v{r_e}
		  eir:pressure-in-mbar
		  eir:trap-depth-in-V eir:beam-radius-in-um)
	  system)
	 ((&values rates dimension) (eir:get-decay-rates system)))
    (make-instance 'ebitodemessages:diff-eq-parameters
		   :initial-values eir:initial-populations
		   :no-dimensions dimension
		   :q-ve (eir:get-qve eir:nuclide-indices eir:v{r_e})
		   :q-vt (eir:get-qvt eir:nuclide-indices eir:trap-depth-in-V)
		   :mass-number (eir:get-mass-numbers eir:nuclide-indices)
		   :d-charge-ex-divided-by-n-times-tau
		   (eir:get-cx-rate-over-t-and-n eir:nuclide-indices
		   				 (ionization-energies:get-ie-for-q-in-natural 7 1)
		   				 eir:pressure-in-mbar)
		   :rate-of-change-divided-by-n rates
		   :spitzer-divided-by-overlap (eir:spitzer-heating-constant system eir:nuclide-indices)
		   :q-ve-over-vol-x-k-t (eir:get-q-ve-over-vol-x-kt eir:nuclide-indices
								    eir:v{r_e}
								    (* 1d-6 eir:beam-radius-in-um)
								    eir:trap-length-in-m)
		   :minimum-n 1d-1
		   :inverted-collision-constant (eir:collision-frequency-t-independent-ij eir:nuclide-indices))))

(make-diff-eq-params (make-instance 'eir:ebit-system
				    :beam-radius-in-um 30d0
				    :initial-populations '((:a 20 :z 8 :q 1 :no 100000d0 :temp-in-ev 5d0))
				    :nuclides (list (nubase:get-entry-for 20 8))))

(defun create-test-msg ()
  (let+ ((system (make-instance 'eir:ebit-system
				:beam-current-in-a 0.1d0
				:trap-depth-in-v 20d0
				:beam-radius-in-um 280d0
				:pressure-in-mbar 1d-10
				:initial-populations '(;;(:a 30 :z 12 :q 1 :no 10000d0 :temp-in-ev 5d0)
						       ;;(:a 133 :z 55 :q 1 :no 100000d0 :temp-in-ev 5d0)
						       (:a 20 :z 10 :q 1 :no 10000d0 :temp-in-ev 5d0))
				:nuclides (list (nubase:get-entry-for 20 10)
						;;(nubase:get-entry-for 133 55)
						)))
	 (problem (make-instance 'ebitodemessages:solve-ode-problem
				 :problem-parameters
				 (make-instance 'ebitodemessages:problem-parameters
						:time-span (make-instance 'ebitodemessages:time-span
									  :start 0.0d0 :stop 5d0)
						:problem-type :ode-problem)
				 :solver-parameters
				 (make-instance 'ebitodemessages:solver-parameters
						:saveat (generate-decade-reporting 1d-6 1000 5d0))
				 :nuclides (eir:nuclide-indices system)
				 :diff-eq-parameters
				 (make-diff-eq-params system))))
    (make-instance 'ebitodemessages:message :msg-type :solve-ode
					    :ode-problem problem)))

(with-open-file (stream "/home/renee/tmp/test_ode.proto"
			:if-exists :supersede
			:direction :output
			:element-type '(unsigned-byte 8))
    (proto:serialize-object-to-stream (create-test-msg) 'ebitodemessages:message :stream stream))


(defun test (port)
  (let+ ((message (create-test-msg))
	 (binary-types:*endian* :little-endian)
	 (byte-buffer (proto:serialize-object-to-bytes message 'ebitodemessages:message)))
    (usocket:with-client-socket (socket stream "localhost" port :element-type '(unsigned-byte 8))
      (binary-types:write-binary 'binary-types:u32 stream (length byte-buffer))
      (write-sequence byte-buffer stream)
      (finish-output stream)

      (let* ((len (binary-types:read-binary 'binary-types:u32 stream))
	     (buffer (make-array len :element-type '(unsigned-byte 8))))
	(read-sequence buffer stream)
	(proto:deserialize-object 'ebitodemessages:message buffer)))))





(proto:deserialize-object-from-file 'ebitode:message "/home/renee/tmp/test4.serialized")

(let+ ((res-msg (proto:deserialize-object-from-file 'ebitodemessages:message
						    "/home/renee/tmp/test_ode_answer.proto"))
       ((&slots ebitodemessages:k-t ebitodemessages:times ebitodemessages:n)
	(ebitodemessages:ode-result res-msg)))
  ,#+nil
  (if (ebitodemessages:error-encountered res-msg)
      (error "Error encountered"))
  (labels ((cmd (fmt-str &rest args)
	     (mgl-gnuplot:command (apply #'format nil fmt-str args))))
    (mgl-gnuplot:with-session ()
      (cmd "reset")
      (cmd "set terminal wxt enhanced size 600,800 font 'Georgia,8' dashed")
      (cmd "set multiplot layout 2,1")
      (cmd "set logscale x")
      ;(cmd "set logscale y")
      
      (mgl-gnuplot:plot*
       (iter
	 (for kt in ebitodemessages:k-t)
	 (for v in ebitodemessages:n)
	 (for a = (ebitodemessages:a (ebitodemessages:nuclide v)))
	 (for i initially 1 then (1+ i))
	 (collect
	     (mgl-gnuplot:data*
	      (iter
		(for tt in ebitodemessages:times)
		(for y in (ebitodemessages:values v))
		(for n in (ebitodemessages:values v))
		(if (> n 1)
		    (collect (list tt (/ y (if (= a 133) 10 1))))))
	      (format nil "with lines dt ~D lw ~D lc ~D title '~a'"
		      (+ (mod i 3))
		      (if (= (mod i 3) 1) 2 1)
		      (ebitodemessages:z (ebitodemessages:nuclide kt)) 
		      (if (= (mod i 3) 1)
			  (format nil "N: ^{~D}~a^{~D+}"
				  (ebitodemessages:a (ebitodemessages:nuclide kt)) 
				  (ionization-energies:get-name-for-z
				   (ebitodemessages:z (ebitodemessages:nuclide kt)))
				  (ebitodemessages:q (ebitodemessages:nuclide kt)))
			  ""))))))
      ;(cmd "set yrange [0:1000]")

      (mgl-gnuplot:plot*
       (iter
	 (for kt in ebitodemessages:k-t)
	 (for v in ebitodemessages:n)
	 (for i initially 1 then (1+ i))
	 (collect
	     (mgl-gnuplot:data*
	      (iter
		(for tt in ebitodemessages:times)
		(for y in (ebitodemessages:values kt))
		(for n in (ebitodemessages:values v))
		(if (and (not (sb-ext:float-nan-p n))
			 (> n 1))
		    (collect (list tt (/ y 1)))))
	      (format nil "with lines dt ~D  lc ~D title '~a'"
		      (+ (mod i 3))
		      (ebitodemessages:z (ebitodemessages:nuclide kt)) 
		      (if (= (mod i 3) 1)
			  (format nil "kT: ^{~D}~a^{~D+}"
				  (ebitodemessages:a (ebitodemessages:nuclide kt)) 
				  (ionization-energies:get-name-for-z
				   (ebitodemessages:z (ebitodemessages:nuclide kt)))
				  (ebitodemessages:q (ebitodemessages:nuclide kt)))
			  "")))))) 
      (cmd "unset output")
      (cmd "unset multiplot")))
  res-msg)
#+END_SRC
** [2018-08-17 Fri 09:30] interaction between lisp and julia is working, 
NA: complete calculations
- first, let's make the rate protobuf a bit more general by introducing a tag indicating
  the type of value represented by the dimension (number, temperature in our case)
- to avoid complications with q=0, remove neutral atoms from the calculations
* ideas / scratch
* differential equations

** heat

we evolve the total energy balance equation since the flow of energy between the
participating particles is dependent on heating/cooling and exchange of particles
themselves. 

Assumptions:
- electron beam current / density unchanged during time evolution

The set of equations for the energy is given by:
#+NAME: eq:energy-balance
\begin{equation}
  \frac{d}{dt} \left[ \frac{3}{2} N_iT_i \right] = 
  \frac{d}{dt} \left[ \frac{3}{2}N_iT_i \right]^{Spitzer} + 
  \frac{d}{dt} \left[ \frac{3}{2}N_iT_i \right]^{Exchange} + 
  \frac{d}{dt} \left[ \frac{3}{2}N_iT_i \right]^{Escape} 
\end{equation}

*** Spitzer heating:
Spitzer heating is given by:
\begin{equation}
  \frac{d}{dt} E^{Spitzer} =
  f_{e,i}N_iJ_e \frac{eq_i^2\ln\Lambda_{e,i}}{4\pi\epsilon_0^2m_iv_e^2} =
  f_{e,i}N_i\ln\Lambda_{e,i}\cdot 1.569\cdot10^{15}\frac{J_e\hat{q}^{2}_i}{\mu_iv_e^2}\ \left[ \frac{eV}{s}  \right]         
\end{equation}

with the electron-ion Coulomb logrithm assumed to be $ln\Lambda_{e,i} = 10$ and the
current density $J_e$ given in A/cm^2 and the electron speed v_e given in cm/s:

*** Escape cooling
\begin{equation}
\left[\frac{dE}{dt}\right]^{escape}
       = - \left( \frac{2}{3}E_{i} + N_iq_iV_t \right)R_i^{Esc}
\end{equation}

*** Heat exchange  
\begin{equation}
  \left[\frac{dE}{dt} \right]^{\mathrm{exchange}}
  = N_i\sum_{j,\alpha}f_{i,j}\tau_{i,j}^{-1}k(T_j-T_i)
  =  \frac{2}{3}\sum_{j,\alpha}\tau_{i,j}^{-1}f_{i,j}\left( E_{j} - E_{i} \right)
\end{equation}

*** overlap factor
the overlap factor is defined as:

#+NAME: eq:overlap-factor
\begin{equation}
  f_{e,i} = \left( \frac{r_e}{r_i} \right)^2	
\end{equation}

and the characteristic radius $r_i$ given as:

#+NAME: eq:ion-characteristic-radius
\begin{equation}
  r_i =
  \begin{cases}
    r_e\sqrt{\frac{k_bT_i}{q_ieV_e}}, & \text{if}\ q_ieV_e > k_bT_i \\
    r_e\exp{\left[ \frac{k_bT_i}{2q_ieV_e}-\frac{1}{2} \right]}, & \text{if}\ q_ieV_e \leq k_bT_i \\
  \end{cases}
\end{equation}

ignoring the difference and assuming the 1/x dependence, we define the
overlap as:

#+NAME: eq:overlap-used
\begin{equation}
  	f_{e,i} = \frac{q_iV_e}{k_bT_i} = \frac{3}{2}q_iV_e\frac{N_i}{E_i}
\end{equation}

using the same simplification we arrive for the ion-ion overlap, at:

#+NAME: eq:ion-ion-overlap
\begin{equation}
  	f_{i,j} = \frac{N_jq_jE_i}{N_iq_iE_j}
\end{equation}

*** density
\begin{equation}
n_i \left( E_i, N_i \right) = \frac{q_iV_e}{L\pi r^2_e}\cdot \frac{N_i^2}{E_i}
\end{equation}

*** ion relaxation time:
#+NAME: eq:ion-relaxation-time
\begin{equation}
  \tau_{ij} = \frac{3(2\pi)^{3/2}\epsilon_0m_im_j}{2q^{2}_iq^2_jn_j\ln\Lambda_{ij}}
  \left( \frac{kT_i}{m_i} + \frac{kT_j}{m_j} \right)^{3/2}
\end{equation}

#+NAME: eq:
\begin{equation}
  \tau_{ij} = 7.37\cdot10^{12}\frac{A_iA_j}{\hat{q}_i^2\hat{q}_j^2n_j\ln\Lambda_{i,j}}
  \times \left( \frac{kT_i}{A_i} + \frac{kT_j}{A_j} \right)^{3/2} \left[ s \right]
  = 4.01\cdot10^{12}\frac{A_iA_j}{\hat{q}_i^2\hat{q}_j^2n_j\ln\Lambda_{i,j}}
  \times \left( \frac{E_i}{N_iA_i} + \frac{E_j}{N_jA_j} \right)^{3/2} \left[ s \right].
\end{equation}


*** Rate of escape
#+NAME: eq:rate-axial-escape
\begin{equation}
  R_i^{Esc} = \frac{3}{\sqrt{3}}\nu_i \frac{e^{-\omega_i}}{\omega_i}, 
\end{equation}
where $\nu_i = \sum_{j,\alpha}f_{i,j}\tau^{-1}_{i,j}$ is the Coulomb collision frequency
for ions of charge state $q_i$ with /all/ other ion species and $\omega_i$ is given by:
#+NAME: eq:ebit-omega-i
\begin{equation}
  \omega_i= \frac{q_iV_t}{kT_i} = \frac{3N_iq_iV_t}{2E_i},  
\end{equation}  

** todos
*** TODO include charge exchange


* Performance enhancements with julia
** TODO look at split ODE types
http://docs.juliadiffeq.org/stable/types/split_ode_types.html
** TODO look at DiffEqOperators
http://docs.juliadiffeq.org/stable/features/diffeq_operator.html


* reusable stuff
** ebit-ode-msg protobuf code
#+BEGIN_SRC shell :results none
export PATH="$PATH:/home/renee/.julia/packages/ProtoBuf/w5yif/plugin/"
export JULIA=~/src/julia-0.6.4/bin/julia 
protoc -I /home/renee/phd/src/ebit-evolution.project/ebit-ode-msg/ \
        --julia_out=/home/renee/phd/src/ebit-evolution.project/ebit-ode-server/\
        /home/renee/phd/src/ebit-evolution.project/ebit-ode-msg/ebit-ode-messages.proto
#+END_SRC

#+RESULTS:

* documentation
** ODE matrix formulation


