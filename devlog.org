* todos 
* logbook
** initial ode
- the plan: write the ode in julia
- to avoid complications with handing over the arrays in the beginning, start by
  generating the matrix in lisp (as will be the case anyways), write it out, read it in in
  julia and then use it
** setting up lisp package to create matrices
#+BEGIN_SRC lisp :results none
(ql:quickload :with-project-dir)
(ql:quickload :fare-quasiquote)
#+END_SRC

#+BEGIN_SRC lisp :results none
(with-project-dir:with-project-dir ("/home/renee/phd/src/charge-distribution.project/")
  (ql:quickload :ebit-interaction-rates)
  (ql:quickload :ebit-differential-equations))
#+END_SRC
*** so, what to do ?
- create a list of indices
- for every index, iterate over the all indices and collect the rate infos
- then, add them appropriately
*** [2018-08-09 Thu 10:05] created rates
- NA: create and integrate protobuf protocol
- then, try it:
#+BEGIN_SRC lisp :results none
(in-package :ebit-interaction-rates)


(write-decay-rates-to-file (make-instance 'ebit-system
					  :nuclides
					  (list (nubase:get-entry-for 20 8)))
			   "/home/renee/tmp/test.serialized"
			   :if-exists :overwrite)


(get-decay-rates (make-instance 'ebit-system
				:nuclides
				(list (nubase:get-entry-for 20 8))))

(proto:deserialize-object-from-file 'ebitode:rate-list "/home/renee/tmp/test.serialized")
#+END_SRC

- renamed protobuf msgs for interaction rates
- now need to use this [[ebit-interaction-rates protobuf code]]
- that seems to work, let's try reading some protobuf files in julia
- ok, I can solve the ODE, but the solution is wrong, so the rates are probably wrong
- ODE seems to be ok, plotting in julia is a disaster, start tomorrow by writing protobuf files
*** [2018-08-11 Sat 10:38] test calling julia from lisp
- okay, we get segfaults upon garbage collection after initializing julia
#+BEGIN_SRC lisp
(ql:quickload :with-project-dir)
(defvar cl-user::*cffi-julia-configuration* '(:julia-location "/home/renee/src/julia-d386e40c17/"))
#+END_SRC

#+RESULTS:
: *CFFI-JULIA-CONFIGURATION*

#+BEGIN_SRC lisp
(with-project-dir:with-project-dir ("/home/renee/phd/src/charge-distribution.project/")
  (ql:quickload :cffi-julia))
#+END_SRC

#+RESULTS:
| :CFFI-JULIA |

#+BEGIN_SRC lisp
(in-package #:cffi-julia)
(jl-init)
#+END_SRC

#+RESULTS:
: ; No value
** [2018-08-13 Mon 09:36] so, let's introduce a pipeserver in julia 
and connect to it 
*** but first: test protobuf protocol via a file
#+BEGIN_SRC lisp
(with-project-dir:with-project-dir ("/home/renee/phd/src/charge-distribution.project/")
  (ql:quickload :ebit-ode-interface))
#+END_SRC

#+RESULTS:
| :EBIT-ODE-INTERFACE |

#+BEGIN_SRC lisp 
(in-package #:ebit-ode-interface)

(defun generate-decade-reporting (start-decade points-per-decade end)
  (iter outer
    (for decade from (log start-decade 10) below (log end 10) by 1d0)
    (for dec = (expt 10 decade))
    (for dec+1 = (expt 10 (1+ decade)))
    (iter
      (for val from dec below dec+1
	   by (/ (- dec+1 dec) (1- points-per-decade)))
      (unless (> val end)
	(in outer (collect val))))))


(defun make-diff-eq-params (system)
  (let+ (((&slots eir:initial-populations eir:initial-temperature-in-ev
		  eir:trap-length-in-m eir:indices eir:v{r_e}
		  eir:trap-depth-in-V eir:beam-radius-in-um)
	  system)
	 ((&values rates dimension) (eir:get-decay-rates system)))
    (make-instance 'ebitodemessages:diff-eq-parameters
		   :initial-population eir:initial-populations
		   :initial-temperature eir:initial-temperature-in-ev
		   :indices eir:indices 
		   :no-dimensions dimension
		   :q-ve (eir:get-qve eir:indices eir:v{r_e})
		   :q-vt (eir:get-qvt eir:indices eir:trap-depth-in-V)
		   :mass-number (eir:get-mass-numbers eir:indices)
		   :rate-of-change-divided-by-n rates
		   :one-over-pi-times-l (/ 1d0 (* pi eir:trap-length-in-m))
		   :electron-radius-in-m-squared (* eir:beam-radius-in-um eir:beam-radius-in-um 1d-12))))

(make-diff-eq-params (make-instance 'eir:ebit-system
				:beam-radius-in-um 100d0
				:initial-populations '((:a 20 :z 8 :q 1 :value 1d0))
				:nuclides (list (nubase:get-entry-for 20 8))))

(defun test (port)
  (let+ ((system (make-instance 'eir:ebit-system
				:beam-radius-in-um 100d0
				:initial-populations '((:a 24 :z 8 :q 1 :value 1d0))
				:nuclides (list (nubase:get-entry-for 24 8))))
	 (problem (make-instance 'ebitodemessages:solve-ode-problem
				 :problem-parameters
				 (make-instance 'ebitodemessages:problem-parameters
						:time-span (make-instance 'ebitodemessages:time-span
									  :start 0.0d0 :stop 15d0)
						:problem-type :ode-problem)
				 :sovler-parameters
				 (make-instance 'ebitodemessages:solver-parameters
						:saveat (generate-decade-reporting 1d-6 200 15))
				 :diff-eq-parameters
				 (make-diff-eq-params system)))
	 (message (make-instance 'ebitodemessages:message :msg-type :solve-ode
							  :ode-problem problem))
	 (binary-types:*endian* :little-endian)
	 (byte-buffer (proto:serialize-object-to-bytes message 'ebitodemessages:message)))
    (usocket:with-client-socket (socket stream "localhost" port :element-type '(unsigned-byte 8))
      (binary-types:write-binary 'binary-types:u32 stream (length byte-buffer))
      (write-sequence byte-buffer stream)
      (finish-output stream)

      (let* ((len (binary-types:read-binary 'binary-types:u32 stream))
	     (buffer (make-array len :element-type '(unsigned-byte 8))))
	(read-sequence buffer stream)
	(proto:deserialize-object 'ebitodemessages:message buffer)))))





(proto:deserialize-object-from-file 'ebitode:message "/home/renee/tmp/test4.serialized")

(let+ ((res-msg (test 2000))
       ((&slots ebitode:values ebitode:times) (ebitode:ode-result res-msg)))
  (labels ((cmd (fmt-str &rest args)
	     (mgl-gnuplot:command (apply #'format nil fmt-str args))))
    (mgl-gnuplot:with-session ()
      (cmd "reset")
      (cmd "set terminal wxt enhanced font 'Georgia,8' dashed")
      (cmd "set logscale x")
      (mgl-gnuplot:plot*
       (iter
	 (for v in ebitode:values)
	 (collect
	     (mgl-gnuplot:data*
	      (iter
		(for tt in ebitode:times)
		(for y in (ebitode:values v))
		(collect (list tt y)))
	      (let ((dt (mod (+ (/ (ebitode:i (ebitode:index v)) 10)) 10)))
		(if (= 0 (ebitode:q (ebitode:index v)))
		    (format nil "with lines dt ~D title '^{~D}~a'"
			    dt
			    (ebitode:a (ebitode:index v)) 
			    (ionization-energies:get-name-for-z (ebitode:z (ebitode:index v))))
y		    (format nil "with lines dt ~D title ''" dt))))))) 
      (cmd "unset output")))
  res-msg)
#+END_SRC
** [2018-08-17 Fri 09:30] interaction between lisp and julia is working, 
NA: complete calculations
- first, let's make the rate protobuf a bit more general by introducing a tag indicating
  the type of value represented by the dimension (number, temperature in our case)
- to avoid complications with q=0, remove neutral atoms from the calculations
* ideas / scratch
* differential equations

* Performance enhancements with julia
** TODO look at split ODE types
http://docs.juliadiffeq.org/stable/types/split_ode_types.html
** TODO look at DiffEqOperators
http://docs.juliadiffeq.org/stable/features/diffeq_operator.html


* reusable stuff
** ebit-ode-msg protobuf code
#+BEGIN_SRC shell :results none
export PATH="$PATH:/home/renee/.julia/packages/ProtoBuf/w5yif/plugin/"
export JULIA=~/src/julia-0.7.0/bin/julia 
protoc -I /home/renee/phd/src/charge-distribution.project/ebit-ode-server/ebit-ode-msg/ \
        --julia_out=/home/renee/phd/src/charge-distribution.project/ebit-ode-server/\
        /home/renee/phd/src/charge-distribution.project/ebit-ode-server/ebit-ode-msg/ebit-ode-messages.proto
#+END_SRC

#+RESULTS:

* documentation
** ODE matrix formulation


